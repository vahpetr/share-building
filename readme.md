# Долевое строительство

Метод преобразует массив из N долей, в процентном выражении с точностью до трех знаков после запятой.

## Требования

Программа тестировалась на `node v10.5.0`

## Установка

```sh
npm install
```

## Запуск

```sh
npm test
npm run perf
```

## Описание

Код проекта состоит из 3х `js` файлов:

1. `share-building.js` код функции;
1. `share-building.spec.js` тесты;
1. `share-building.perf.js` синтетический тест производительности.

И одной зависимости для тестирования `jest`.

В проекте используется старая `node` система зависимостей по причинам:

1. `jest` из коробки не умеет работать с `es6` в особенности ключевыми словами 'import/export' без включения в проект ещё 4х зависимостей `babel-jest babel-core regenerator-runtime babel-preset-env`;
1. `node v10.5.0-10.6.0` не умеет работать с зависимостями `es6`, только если запускать его с флагом `-experimental-modules`.

Для упрощения и уменьшения кода и более стабильных результатов при тестировании производительности, пришлось отказаться от `es6`.

### Сложность алгоритма

Сложность алгоритма составила 2N.

### Потребление памяти и время выполнения

```sh
npm run perf
```

При тестировании производительности для уменьшения и упрощения кода использовались нативные возможности `nodejs`, в реальном проекте было бы неплохо использовать такие пакеты как [node-memwatch](https://github.com/lloyd/node-memwatch) и [leakage](https://github.com/andywer/leakage).
Тестирование проходило на Mac Book Pro 2,2 GHz Intel Core i7 16 ГБ 1600 MHz DDR3. За результат брался каждый четвёртый вызов `npm run perf` с заданным количеством элементов. На данной машине реализация показала следующие результаты:

|Количество элементов|Время выполнения|Выделено памяти|Использовано памяти|
| :---               | :---           | :---          | :---              |
| 1e6                | 725 ms         | 117.33 mb     | 99.99 mb          |
| 5.2e6              | 3764 ms        | 373.96 mb     | 336.74 mb         |
| 6.2e6              | 4449 ms        | 411 mb        | 375.37 mb         |
| 7e6                | 5018 ms        | 543.24 mb     | 507.23 mb         |

### Ограничение входного массива

Для данной машины буду считать разумным ограничением длину массива равную 7e6 элементов. При таком значении алгоритм выполняется приблизительно за 5 секунд.

## Тестирование

```sh
npm test
```

Тестировались возможные значения для метода(рациональные числа), граничные(min и max), а также значения порождающие исключения. Всего 11 тестов.
Не тестировались случаи получения на вход методом не рациональных чисел (по условию задачи могут быть только они), а также не массивов (за исключением `null`) так как предполагается что в реальном проекте будет использоваться `typescript` и такого не может произойти (хотя так же остаётся возможным).

## Заключение

1. В реальном веб приложении на клиентской стороне не рекомендую оперировать столь большими объёмами данных, 1 000 000 уже более чем достаточно.
1. Клиентские машины могут очень сильно разниться в производительности, у клиентского устройства производительность этого же кода может быть на порядок ниже, это тоже необходимо учитывать.
1. Данный код желательно использовать исключительно в тестовых целях, сервер должен возвращать ответы в удобном для обработки на клиентской стороне виде.
1. В приложениях при обработки данных большего объёма(если всё же пришлось) предпочтительней использовать [генераторы](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*)
1. На выполнение задачи потребовалось 3 часа 25+15 минут.

## Приложение

### Сравнительная таблица отброшенного 2-го варианта решения

```javascript
const compute = array => {
    const numbers = array.map(parseFloat);
    const sum = numbers.reduce((accumulate, value) => accumulate + value, 0);
    const divider = sum / 100;
    const result = numbers.map(value => (value / divider).toFixed(3));
    return result;
};
```

Сложность алгоритма 3N.

|Количество элементов|Время выполнения|Выделено памяти|Использовано памяти|
| :---               | :---           | :---          | :---              |
| 1e6                | 969 ms         | 102.98 mb     | 84.7 mb           |
| 5.2e6              | 4963 ms        | 347.78 mb     | 315.83 mb         |
| 6.2e6              | 5873 ms        | 400.96 mb     | 372.72 mb         |
| 7e6                | 6561 ms        | 440.3 mb      | 412.54 mb         |

### Сравнительная таблица отброшенного 3-го варианта решения

```javascript
const compute = array => {
    const result = [], l = array.length;
    let sum = 0, i = 0;
    for(; i < l; i++) {
        sum += (result[i] = parseFloat(array[i]));
    }
    const divider = sum / 100;
    for(i = 0; i < l; i++) {
        result[i] = (result[i] / divider).toFixed(3);
    }
    return result;
};
```

Сложность алгоритма 2N.

|Количество элементов|Время выполнения|Выделено памяти|Использовано памяти|
| :---               | :---           | :---          | :---              |
| 1e6                | 801 ms         | 139.21 mb     | 103.84 mb         |
| 5.2e6              | 4326 ms        | 486.95 mb     | 417.24 mb         |
| 6.2e6              | 4991 ms        | 534.18 mb     | 472.37 mb         |
| 7e6                | 5793 ms        | 487.75 mb     | 421.27 mb         |

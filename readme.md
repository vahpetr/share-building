# Долевое строительство

Метод преобразует массив из N долей, в процентном выражении с точностью до трех знаков после запятой.

## Требования

Программа тестировалась на `node v10.5.0`

## Установка

```sh
npm install
```

## Запуск

```sh
npm test
npm run perf
```

## Описание

Код проекта состоит из 3х `js` файлов:

    1. `share-building.js` код функции;
    1. `share-building.perf.js` тесты;
    1. `share-building.perf.js` синтетический тест производительности.

И одной зависимости для тестирования `jest`.

В проекте используется старая `node` система зависимостей так как:

    1. `jest` из коробки не умеет работать с `es6` ключевыми словами 'import/export' без ещё 4х зависимостей `babel-jest babel-core regenerator-runtime babel-preset-env`;
    1. `node 10.5.0-10.6.0` не умеет работать с зависимостями `es6`, только если запускать его с флагом `-experimental-modules`.

Для упрощения и уменьшения кода и более стабильных результатов при тестировании производительности пришлось отказаться от `es6`.

### Сложность алгоритма

Сложность алгоритма составила 2N.

### Потребление памяти и время выполнения

Для тестирование производительности использовались нативные возможности `nodejs` для уменьшения и упрощение кода, в реяльном проекте было бы неплохо использовать такие пакеты как [node-memwatch](https://github.com/lloyd/node-memwatch) и [leakage](https://github.com/andywer/leakage).
Тестирование проходило на Mac Book Pro 2,2 GHz Intel Core i7 16 ГБ 1600 MHz DDR3. За результат брался каждый четвёртый вызов `npm run perf` с заданным количеством элементов. На данной машине реализация показала следующие результаты:

|Количество элементов|Время выполнения|Выделено памяти |Использовано памяти |
| :---               | :---           | :---           | :---               |
| 1e6                | 725 ms         | 117.33 mb      | 99.99 mb           |
| 5.2e6              | 3764 ms        | 373.96 mb      | 336.74 mb          |
| 6.2e6              | 4449 ms        | 411 mb         | 375.37 mb          |
| 7e6                | 5018 ms        | 543.24 mb      | 507.23 mb          |

### Ограничение входного массива

Для данной машины быду считать разумным ограничением длинну массива равную 7e6 элементов.

## Тестирование

```sh
npm test
```

Тестировались возможные значения для метода, граничные, а также значения порождающие исключения. Всего 11 тестов.
Не тестировались случии получения на вход методом не рациональных чисел (по условию задачиб могут быть только они), а так же не массивов (за исключением null) так как предпологается что в ряльном проекте будет использоваться `typescript` и такого не может произойти(хотя так же остаётся возможным).

## Заключение

1. В ряльном веб приложении на клиентской стороне не реккомендуется опперировать такими объёмами данных, 1/10 уже больше, чем нужно.
1. Клиентские машины могут очень сильно разниться в производительности, в ряльности у клиентского устройства производительность это го же кода может быть на порядок ниже.
1. Данный код желательно использовать исключительно в тестовых целях, сервер должен возвращать ответы в удобном для обработки на клиентской стороне виде.
1. На задачу ушло 3 часа 25 минут.

## Прложение

### Сравнительная таблица отброшенного второго варианта решения

```javascript
const compute = array => {
    const numbers = array.map(parseFloat);
    const sum = numbers.reduce((accumulate, value) => accumulate + value, 0);
    const divider = sum / 100;
    const result = numbers.map(value => (value / divider).toFixed(3));
    return result;
};
```

|Количество элементов|Время выполнения|Выделено памяти |Использовано памяти |
| :---               | :---           | :---           | :---               |
| 1e6                | 969 ms         | 102.98 mb      | 84.7 mb            |
| 5.2e6              | 4963 ms        | 347.78 mb      | 315.83 mb          |
| 6.2e6              | 5873 ms        | 400.96 mb      | 372.72 mb          |
| 7e6                | 6561 ms        | 440.3 mb       | 412.54 mb          |

### Сравнительная таблица отброшенного третьего варианта решения

```javascript
const compute = array => {
    const result = [], l = array.length;
    let sum = 0, i = 0;
    for(; i < l; i++) {
        sum += (result[i] = parseFloat(array[i]));
    }
    const divider = sum / 100;
    for(i = 0; i < l; i++) {
        result[i] = (result[i] / divider).toFixed(3);
    }
    return result;
};
```

|Количество элементов|Время выполнения|Выделено памяти |Использовано памяти |
| :---               | :---           | :---           | :---               |
| 1e6                | 801 ms         | 139.21 mb      | 103.84 mb          |
| 5.2e6              | 4326 ms        | 486.95 mb      | 417.24 mb          |
| 6.2e6              | 4991 ms        | 534.18 mb      | 472.37 mb          |
| 7e6                | 5793 ms        | 487.75 mb      | 421.27 mb          |
